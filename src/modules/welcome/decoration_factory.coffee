angular.module "voice-signup"
.factory 'decoration_factory',[()->
    factory = this
    factory.text = " 
    object merge_sort extends App{
        def mergeSort(xs:List[Int]):List[Int] = {
        def merge( xs:List[Int], ys:List[Int]):List[Int] = {
            var breakOuter:Boolean = false
            var breakInner:Boolean = false
            var outerCount:Int = 0
            var i = 0;
            val zs = for( 
            n <- xs; 
            outerCount:Int = outerCount + 1;
            if(!breakOuter);
            innerCount = i;
            merged = 0;
            k <-ys;
            breakI = breakInner;
            if(!breakI)
            ) yield {
            i = i +  1
            if(n > k){
                if(outerCount == xs.length){
                n :: ys
                }
                else{
                breakInner = true
                n
                }
            }
            else{
                if(innerCount == ys.length){
                breakOuter = true
                k :: xs
                }else{
                k 
                }
            }
            }

            val res = zs.foreach( s => for(n <- s) yield { n.asInstanceOf[Int] })
            res
        }
        def sort(xs:List[Int]):List[Int] = {
            if(xs.length > 1){
            merge(sort(xs.take(xs.length/2)),sort(xs.drop(xs.length/2)))
            }else{
            xs
            }
        }

        sort(xs)
        }
        val xs = 2 ::3 :: 12 :: 3 :: 5 :: 10 :: Nil
        Console print mergeSort(xs);
    } 
    object merge_sort extends App{
        def mergeSort(xs:List[Int]):List[Int] = {
        def merge( xs:List[Int], ys:List[Int]):List[Int] = {
            var breakOuter:Boolean = false
            var breakInner:Boolean = false
            var outerCount:Int = 0
            var i = 0;
            val zs = for( 
            n <- xs; 
            outerCount:Int = outerCount + 1;
            if(!breakOuter);
            innerCount = i;
            merged = 0;
            k <-ys;
            breakI = breakInner;
            if(!breakI)
            ) yield {
            i = i +  1
            if(n > k){
                if(outerCount == xs.length){
                n :: ys
                }
                else{
                breakInner = true
                n
                }
            }
            else{
                if(innerCount == ys.length){
                breakOuter = true
                k :: xs
                }else{
                k 
                }
            }
            }

            val res = zs.foreach( s => for(n <- s) yield { n.asInstanceOf[Int] })
            res
        }
        def sort(xs:List[Int]):List[Int] = {
            if(xs.length > 1){
            merge(sort(xs.take(xs.length/2)),sort(xs.drop(xs.length/2)))
            }else{
            xs
            }
        }

        sort(xs)
        }
        val xs = 2 ::3 :: 12 :: 3 :: 5 :: 10 :: Nil
        Console print mergeSort(xs);
    } 
    object merge_sort extends App{
        def mergeSort(xs:List[Int]):List[Int] = {
        def merge( xs:List[Int], ys:List[Int]):List[Int] = {
            var breakOuter:Boolean = false
            var breakInner:Boolean = false
            var outerCount:Int = 0
            var i = 0;
            val zs = for( 
            n <- xs; 
            outerCount:Int = outerCount + 1;
            if(!breakOuter);
            innerCount = i;
            merged = 0;
            k <-ys;
            breakI = breakInner;
            if(!breakI)
            ) yield {
            i = i +  1
            if(n > k){
                if(outerCount == xs.length){
                n :: ys
                }
                else{
                breakInner = true
                n
                }
            }
            else{
                if(innerCount == ys.length){
                breakOuter = true
                k :: xs
                }else{
                k 
                }
            }
            }

            val res = zs.foreach( s => for(n <- s) yield { n.asInstanceOf[Int] })
            res
        }
        def sort(xs:List[Int]):List[Int] = {
            if(xs.length > 1){
            merge(sort(xs.take(xs.length/2)),sort(xs.drop(xs.length/2)))
            }else{
            xs
            }
        }

        sort(xs)
        }
        val xs = 2 ::3 :: 12 :: 3 :: 5 :: 10 :: Nil
        Console print mergeSort(xs);
    } 
    object merge_sort extends App{
        def mergeSort(xs:List[Int]):List[Int] = {
        def merge( xs:List[Int], ys:List[Int]):List[Int] = {
            var breakOuter:Boolean = false
            var breakInner:Boolean = false
            var outerCount:Int = 0
            var i = 0;
            val zs = for( 
            n <- xs; 
            outerCount:Int = outerCount + 1;
            if(!breakOuter);
            innerCount = i;
            merged = 0;
            k <-ys;
            breakI = breakInner;
            if(!breakI)
            ) yield {
            i = i +  1
            if(n > k){
                if(outerCount == xs.length){
                n :: ys
                }
                else{
                breakInner = true
                n
                }
            }
            else{
                if(innerCount == ys.length){
                breakOuter = true
                k :: xs
                }else{
                k 
                }
            }
            }

            val res = zs.foreach( s => for(n <- s) yield { n.asInstanceOf[Int] })
            res
        }
        def sort(xs:List[Int]):List[Int] = {
            if(xs.length > 1){
            merge(sort(xs.take(xs.length/2)),sort(xs.drop(xs.length/2)))
            }else{
            xs
            }
        }

        sort(xs)
        }
        val xs = 2 ::3 :: 12 :: 3 :: 5 :: 10 :: Nil
        Console print mergeSort(xs);
    object merge_sort extends App{
        def mergeSort(xs:List[Int]):List[Int] = {
        def merge( xs:List[Int], ys:List[Int]):List[Int] = {
            var breakOuter:Boolean = false
            var breakInner:Boolean = false
            var outerCount:Int = 0
            var i = 0;
            val zs = for( 
            n <- xs; 
            outerCount:Int = outerCount + 1;
            if(!breakOuter);
            innerCount = i;
            merged = 0;
            k <-ys;
            breakI = breakInner;
            if(!breakI)
            ) yield {
            i = i +  1
            if(n > k){
                if(outerCount == xs.length){
                n :: ys
                }
                else{
                breakInner = true
                n
                }
            }
            else{
                if(innerCount == ys.length){
                breakOuter = true
                k :: xs
                }else{
                k 
                }
            }
            }

            val res = zs.foreach( s => for(n <- s) yield { n.asInstanceOf[Int] })
            res
        }
        def sort(xs:List[Int]):List[Int] = {
            if(xs.length > 1){
            merge(sort(xs.take(xs.length/2)),sort(xs.drop(xs.length/2)))
            }else{
            xs
            }
        }

        sort(xs)
        }
        val xs = 2 ::3 :: 12 :: 3 :: 5 :: 10 :: Nil
        Console print mergeSort(xs);
    } 
    object merge_sort extends App{
        def mergeSort(xs:List[Int]):List[Int] = {
        def merge( xs:List[Int], ys:List[Int]):List[Int] = {
            var breakOuter:Boolean = false
            var breakInner:Boolean = false
            var outerCount:Int = 0
            var i = 0;
            val zs = for( 
            n <- xs; 
            outerCount:Int = outerCount + 1;
            if(!breakOuter);
            innerCount = i;
            merged = 0;
            k <-ys;
            breakI = breakInner;
            if(!breakI)
            ) yield {
            i = i +  1
            if(n > k){
                if(outerCount == xs.length){
                n :: ys
                }
                else{
                breakInner = true
                n
                }
            }
            else{
                if(innerCount == ys.length){
                breakOuter = true
                k :: xs
                }else{
                k 
                }
            }
            }

            val res = zs.foreach( s => for(n <- s) yield { n.asInstanceOf[Int] })
            res
        }
        def sort(xs:List[Int]):List[Int] = {
            if(xs.length > 1){
            merge(sort(xs.take(xs.length/2)),sort(xs.drop(xs.length/2)))
            }else{
            xs
            }
        }

        sort(xs)
        }
        val xs = 2 ::3 :: 12 :: 3 :: 5 :: 10 :: Nil
        Console print mergeSort(xs);
    } 
    } 
    "

    return factory

    ]
